---
layout: article
category: dev
tags:
  - full_post
title: Comment j'aurais aim√© qu'on m'explique Git 
---




## Introduction

### Pr√©sentation
Git est un logiciel de gestion de versions d√©centralis√©. C'est un logiciel libre et gratuit, cr√©√© en 2005 par Linus Torvalds, auteur du noyau Linux.

<!--more-->

D√©finitions :

- gestionnaire de versions : outil permettant de versionner un ensemble de dossiers et fichiers.
- d√©centralis√© : s'oppose √† centralis√©, c'est √† dire √† un r√©pertoire central stockant toutes les versions. Ici chaque d√©veloppeur poss√®de le r√©pertoire qui contient l'int√©gralit√© de l'historique et des versions du projet.
- Linus Torvalds : un chic type

Il r√©pond notamment aux besoins suivants :

1. ne pas perdre les fichiers
2. pouvoir revenir en arri√®re
3. travailler en √©quipe
4. partager le projet et int√©grer des personnes que l'on ne conna√Æt pas
5. h√©berger un projet √† l‚Äôext√©rieur de son ordinateur

Git est un outil qui permet de travailler collaborativement et parall√®lement sur le m√™me projet.  

### Ecosyst√®me

- Git est au coeur d'un √©cosyst√®me tr√®s important pour le d√©veloppement. Gitlab et Github, deux produits concurrents qui permettent d'h√©berger des projets bas√©s sur Git. 
- Git est int√©gr√© √† la plupart des IDE (VSCode, PyCharm, Intellij, RStudio, Eclipse etc.)
- Git permet le DevOps et le DataOps, c'est √† dire l'automatisation des cha√Ænes de livraison de nouvelles versions.

### Pourquoi utiliser un gestionnaire de version ?

Avant :

1. `toto_v0.txt`
2. `toto_v1.txt`
3. `toto_v1_judith.txt`
4. `toto_v1_jj_20230412.txt`
5. `toto_v1_jj_20230412_final.txt`
6. `toto_v1_jj_20230412_final0.txt`
7. `toto_v1_jj_20230412_final0_final.txt`


Apr√®s :

| Document   | Version | Parent |
| ---------- | ------- | ------ |
| `toto.txt` | A       | ‚àÖ      |
| `toto.txt` | B       | A      |
| `toto.txt` | C       | B      |
| `toto.txt` | Z       | A      |

Git va nous permettre de g√©rer les versions automatiquement.    
A la base, c'est vrai que git est plut√¥t orient√© pour le d√©veloppement logiciel et pour les d√©veloppeurs.
Cependant, on peut tr√®s bien l'utiliser pour d'autres usages :

- g√©rer des version de documents, de documentations
- versionner des configurations
- versionner des notes personnelles (j'utilise [Obsidian](obsidian.md)+git par exemple pour la prise de note et la sauvegarde, voir √©galement [LogSeq](https://logseq.com/))

Vous pourrez √©galement utiliser tout l'√©cosyst√®me qui tourne autour de Git.

### Installation

Voir ici : [D√©marrage rapide - Installation de Git](https://git-scm.com/book/fr/v2/D%C3%A9marrage-rapide-Installation-de-Git)  
ou voir la [doc du SEBIMER](https://cloud.ifremer.fr/index.php/s/Gxi6jxTDAxkxNzz).


### Configuration
_git config_

Afin de configurer Git pour se connecter au GitLab Ifremer de mani√®re s√©curis√©e, ex√©cuter les commandes suivantes.
```bash
# d√©finition de username : nom ou nom pr√©nom ou login intranet par exemple
git config --global user.name <usename>
# d√©finition de votre email : email ifremer pour trvailler sur le gitlab Ifremer
git config --global user.email <email>
# definition du login de connexion pour le gitlab Ifremer
git config --global credential.https://gitlab.ifremer.fr.username <login_extranet>
# r√©initialisation du cache toutes les 8h (permet de renseigner son mot de passe une seule fois / jour)
git config --global credential.https://gitlab.ifremer.fr.helper "cache --timeout=30000"

# Exemple
git config --global user.name "L√©o Le Lonquer"
git config --global user.email leo.le.lonquer@ifremer.fr
git config --global credential.https://gitlab.ifremer.fr.username ll7aa35
```

## Concepts de bases

### D√©p√¥t
_git init, git status_ 

Imaginons le projet avec l'arborescence suivante : 

<pre><font color="#12488B"><b>myproject/</b></font>
‚îî‚îÄ‚îÄ toto.txt
</pre>

Pour sauvegarder le contenu de dir, nous allons cr√©er un d√©p√¥t (repository ou repo) git.  
Nous obtenons l'arborescence suivante :

<pre><font color="#12488B"><b>myproject/</b></font> => Arbre de travail
‚îú‚îÄ‚îÄ toto.txt
‚îî‚îÄ‚îÄ <font color="#12488B"><b>.git</b></font> => D√©p√¥t
</pre>

Toutes les informations de versionnement seront stock√©es le dossier `.git`. Ce dossier est appel√© d√©p√¥t. Il pourrait √™tre stock√© n'importe o√π.  
Le dossier `myproject` est l'arbre de travail. C'est dans ce dossier qu'on peut apporter des modifications √† nos fichiers et les versionner. 

Le fichier `toto.txt` n'aura pas besoin de changer de nom.

![cone](../assets/images/cone-svgrepo-com.svg) **TP**  Cr√©er et initialiser son projet

Ouvrir un terminal 
```bash
mkdir myproject # Cr√©er le dossier
cd myproject # Aller dans le dossier
echo "bonjour" > toto.txt # Cr√©er un fichier toto.txt
git init # initialiser le projet en tant 
ls -a # V√©rfier l'existence du dossier .git
# .  ..  .git  toto.txt

git status # Afficher le statut de l'arbre de travail
```
Sortie :

<pre>Sur la branche main

Aucun commit

Fichiers non suivis:
  (utilisez &quot;git add &lt;fichier&gt;...&quot; pour inclure dans ce qui sera valid√©)
	<font color="#C01C28">toto.txt</font>

aucune modification ajout√©e √† la validation mais des fichiers non suivis sont pr√©sents (utilisez &quot;git add&quot; pour les suivre)
</pre>

Pas g√©nial, ya du rouge. La suite dans le TP suivant.

### Commit (r√©vision/version)
_git add, git commit, git log_ 

Le repo est initialis√©, mais rien n'a encore √©t√© versionn√© dans le repo.   
Dans git, une version/r√©vision est appel√©e un commit.

Pour cr√©er un commit, il y a deux √©tapes :  

1. `git add` a deux fonctions : 
    - ajouter des nouveaux fichiers √† l'index des fichiers suivis par git
    - stocker les modifications dans une zone interm√©diaire, la staging area (zone de transit) qui nous permet de faire de la v√©rification sur les fichiers qu'on int√®gre dans une r√©vision. 
2. `git commit` : sauvegarde les modifications de tous les fichiers pr√©sents dans la staging area dans le dossier `.git/` et produit un commit avec une cl√© SHA1.

```txt
 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 ‚îÇWorking Tree‚îÇ‚îÇStaging Area‚îÇ‚îÇLocal Repo‚îÇ
 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ             ‚îÇ            ‚îÇ      
       ‚îÇ   git add   ‚îÇ            ‚îÇ      
       ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ            ‚îÇ      
       ‚îÇ             ‚îÇ            ‚îÇ      
       ‚îÇ             ‚îÇ git commit ‚îÇ      
       ‚îÇ             ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ      
       ‚îÇ             ‚îÇ            ‚îÇ      
       ‚îÇ   git checkout/switch    ‚îÇ      
       ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ      
       ‚îÇ             ‚îÇ            ‚îÇ      
       ‚îÇ        git merge         ‚îÇ      
       ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ      
```

_Un fichier peut √™tre r√©f√©renc√© dans 3 zones : l'arbre de travail, la zone de transit et le d√©p√¥t._  
_Pour le versionnement, il devra passer par ces trois zones successivement._

A chaque fois que vous versionner gr√¢ce aux commandes `git add` + `git commit`, vous cr√©ez un nouveau commit qui s'ajoute dans une cha√Æne, une lign√©e de commits. 

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇcommit C‚îÇ C h√©rite de B
‚îî‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚ñΩ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇcommit B‚îÇ B h√©rite de A
‚îî‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚ñΩ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇcommit A‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```
_Exemple de graphe de lign√©e de commits. Le commit le plus r√©cent est C, B est son commit parent. A est le commit le plus ancien._

Plus pr√©cis√©ment, pour chaque commit, il se passe ceci :

- Git versionne sur l'int√©gralit√© de l'arbre de travail. Lors de la cr√©ation d'un commit, git fait une photographie de l'instant en stockant les modifications apport√©es dans le projet dans le dossier `.git/` et en attribuant √† cette photographie un identifiant cryptographique unique SHA1 (ex: `338b0b72fefb35d6e374127768aed10642aada0b`, raccourci en 7 caract√®res `338b0b7`)  
- Chaque commit est associ√© √† un ou plusieurs commits parents ce qui nous permettra de retrouver l'historique.

!!! tip
	C'est √† vous de choisir √† quel moment versionner votre travail. Il n'y a pas vraiment de convention. Consid√©rez simplement un moment qui est un point de sauvegarde pour votre projet. Vous pouvez versionner autant que vous voulez, git est tr√®s robuste quant au nombre de commits.

![cone](../assets/images/cone-svgrepo-com.svg) **TP**  Versionner son projet
```bash
git add toto.txt # Ajout √† l'index et stockage des modifications dans la staging area 
git commit -m "Mon premier commit" # Cr√©ation d'un commit avec un message
git log # Visualisation de l'historique de commits
```
Sortie :

<pre><font color="#A2734C">commit 34c9d3c50746bf01df0e3e7a9ec9c59f2803aa17 (</font><font color="#2AA1B3"><b>HEAD -&gt; </b></font><font color="#26A269"><b>main</b></font><font color="#A2734C">)</font>
Author: L√©o Le Lonquer &lt;leo.le.lonquer@ifremer.fr&gt;
Date:   Thu Apr 4 09:50:48 2024 +0200

    Mon premier commit
</pre>

Amusez-vous √† modifier le fichier `toto.txt`, √† le versionner, √† v√©rifier l'√©tat de votre repo avec `git status` et √† regarder les logs avec `git log`.

### Branches et arborescence üåø

#### Branchage et merge
_git branch, git switch, git merge_

Pour l'instant nous √©tions sur un repo tr√®s simple. Imaginons que nous voulons ajouter une fonctionnalit√© sans casser l'√©tat actuel de notre projet. Nous pouvons cr√©er une branche qui permettra de travailler √† c√¥t√© sur cette nouvelle fonctionnalit√© tranquillement.  

- Nous pouvons cr√©er autant de branches que souhait√©, √† partir de n'importe quelle branche. Vous allez donc cr√©er une arborescence, qui s'apparente √† un arbre g√©n√©alogique.
- Par d√©faut, nous sommes la branche principale `main` (`master` pour des projets plus anciens).

```txt
		  E---F---G topic
		 /
	A---B---C---D main
```
_Graphe d'un repo pr√©sentant une branche `topic` issue de la branche `main`_


Une fois que les fonctionnalit√©s sont d√©velopp√©es et matures, nous pouvons ramener les modifications d'une branche dans une autre. C'est ce qu'on appelle un merge.

```txt
		  E---F---G topic
		 /         \
	A---B---C---D---H main
```
_Exemple de graphe apr√®s un merge_

![cone](../assets/images/cone-svgrepo-com.svg) **TP 1**  Cr√©er une branche, basculer dessus et observer les effets du basculement

Toujours avec le m√™me projet

```bash
git branch topic # Cr√©er la branche √† partir du dernier commit
git switch topic # changer de branche
# Ou les deux commandes en une
git switch -c topic

git branch # Afficher les branches existantes
#   main
# * topic
```

Vous ne verrez pas de diff√©rences au premier abord. Ajoutons un fichier et versionnons l'√©tat.

```bash
echo "coucou" > tutu.py # Cr√©er un nouveau fichier
git add . && git commit -m "Premier commit de la branche topic"
ls 
# toto.txt  tutu.py
```

Une fois commit√© revenons √† main.

```bash
git switch main
ls # O√π est pass√© le fichier `tutu.py` ?
# toto.txt

git log
```

Vous ne verrez pas le commit avec le message "Premier commit de la branche topic" car vous √™tes sur la branche `main` qui n'a pas encore int√©gr√© les modifications faites sur `topic` (heureusement !). 

Rassurez-vous le fichier `tutu.py` n'est pas perdu, il est simplement dans le dossier `.git/` et attend que vous reveniez le voir. Git s'est charg√© de modifier votre espace de travail courant pour revenir √† un espace de travail correspondant √† une autre branche.

```bash
git switch topic # Revenons √† la branche topic
ls # Le fichier tutu.py r√©appara√Æt
# toto.txt  tutu.py
```

![cone](../assets/images/cone-svgrepo-com.svg)**TP 2** Faire un merge

Maintenant imaginons que nous avons termin√© le d√©veloppement de notre fonctionnalit√©, nous voulons r√©int√©grer les d√©veloppement dans la branche principale.

Le graphe de commit ests dans l'√©tat suivant : 
```txt
		  B topic
		 /
	0---A main
```

Ex√©cutons le merge
```bash
git switch main 
git merge topic --no-ff # l'option --no-ff est pour la cosm√©tique du graphe de commits, elle n'est pas utilis√©e usuellement
ls # tutu.py est pr√©sent
```

git cr√©e un nouveau commit appel√© merge commit pour signaler que vous avez int√©gr√© les modifications du dernier commit de la branche topic.

Le graphe de commits se retrouve dans l'√©tat suivant :
```txt
		  B topic
		 / \
	0---A---C main
```
#### Les r√©f√©rences (branche-HEAD-tag)
_git log --graph, git checkout, git tag_

Les r√©f√©rences sont des pointeurs qui identifient un commit dans un graphe de commits. Il existe trois types de r√©f√©rences :

- **HEAD** : c'est la r√©f√©rence de l'arbre de travail courant. A chaque commit, il est mis √† jour. Il peut avoir deux √©tats :
	- **attach√©** : il pointe vers une branche qui elle-m√™me pointe vers un commit
	- **d√©tach√©** : il ne pointe vers aucune branche, mais vers n'importe quel commit du graphe
- **les branches** : les branches ne sont en r√©alit√© que des pointeurs. Elles identifient un dernier commit d'une cha√Æne de commits. L'h√©ritage se fait de proche en proche (rappelez-vous les commits stockent leur commit parent.). Si HEAD est associ√© √† la branche, alors la r√©f√©rence de la branche est mise √† jour lors d'un commit.
- **tag** : r√©f√©rence immutable (qui n'est jamais mis √† jour) permettant de labeliser des commits plus importants que d'autres (ex : une version livrable du projet).

```
                 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                 ‚îÇcommit W (topic <= HEAD)‚îÇ
                 ‚îî‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñΩ‚îê                                 
‚îÇcommit X (main)   ‚îÇ                                 
‚îî‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                 
‚îå‚ñΩ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                           
‚îÇcommit Y‚îÇ                                           
‚îî‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                           
‚îå‚ñΩ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                           
‚îÇcommit Z‚îÇ                                           
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                           
```
_Exemple de graphe et des pointeurs_

![cone](../assets/images/cone-svgrepo-com.svg) **TP**  Se balader dans le graphe des commits

Vous pouvez afficher le graphe de commits ainsi que l'√©tat des pointeurs 
```bash 
git log --oneline --decorate --all --graph
```
Sortie :

<pre>*   <font color="#A2734C">316d42d (</font><font color="#2AA1B3"><b>HEAD -&gt; </b></font><font color="#26A269"><b>main</b></font><font color="#A2734C">)</font> Merge branch &apos;topic&apos;
<font color="#C01C28">|</font><font color="#26A269">\</font>  
<font color="#C01C28">|</font> * <font color="#A2734C">f6c8d25 (</font><font color="#26A269"><b>topic</b></font><font color="#A2734C">)</font> Premier commit de la branche topic
<font color="#C01C28">|/</font>  
* <font color="#A2734C">65b6302</font> Mon premier commit
</pre>

Nous observons le graphe r√©sultant du merge pr√©c√©dent.   
D√©pla√ßons nous dans un commit :
```bash
git checkout 65b6302
ls
# toto.txt
```

R√©examinons la carte :
```bash
# Revoir la carte et regarder o√π est plac√© le point HEAD
git log --oneline --decorate --all --graph 
```
Sortie :

<pre>*   <font color="#A2734C">316d42d (</font><font color="#26A269"><b>main</b></font><font color="#A2734C">)</font> Merge branch &apos;topic&apos;
<font color="#C01C28">|</font><font color="#26A269">\</font>  
<font color="#C01C28">|</font> * <font color="#A2734C">f6c8d25 (</font><font color="#26A269"><b>topic</b></font><font color="#A2734C">)</font> Premier commit de la branche topic
<font color="#C01C28">|/</font>  
* <font color="#A2734C">65b6302 (</font><font color="#2AA1B3"><b>HEAD</b></font><font color="#A2734C">)</font> Mon premier commit
</pre>

Nous observons que le pointeur `HEAD` s'est d√©plac√© sur le commit `65b6302`. Nous retrouvons uniquement les fichiers qui correspondent √† ce commit.

Repla√ßons HEAD √† son pointage pr√©c√©dent
```bash
git checkout - 
git log --oneline --decorate --all --graph 
```
Nous retrouvons le premier graphe.

#### Convention de nommage de branche

Les branches peuvent √™tre utilis√©es et nomm√©es tr√®s librement. Cependant quelques conventions ont √©t√© cr√©√©es pour que les d√©veloppeurs retrouvent leurs marques entre diff√©rents projets. Je vous pr√©sente ici la nomenclature [git-flow](https://danielkummer.github.io/git-flow-cheatsheet/index.fr_FR.html) : 

1. la branche `main` ou `master` : c'est la branche principale, de r√©f√©rence, qui reproduit la production. Elle doit toujours √™tre fonctionnelle.
2. la branche `dev` ou `develop` : c'est la branche de d√©veloppement, celle qui va proposer une nouvelle version d'un logiciel et dans laquelle on va merger toutes les features.
3. `feature` : ce sont les branches d'ajout de fonctionnalit√©s. Elles sont nomm√©es g√©n√©ralement `feature/[ma_fonctionnalite]` (ex : `feature/add_refresh_button`). Dans certaines organisations, on r√©f√©rence le num√©ro de ticket correspondant √† la feature (ex: `feature/DTL-92_add_refresh_button` voire m√™me simplement `feature/DTL-92`)
4. `hotfix` : pour corriger un bug dans la branche de production `main` et la reporter dans `dev` 

Pour des d√©veloppements simples, si vous √™tes le seul contributeur, vous pouvez utiliser seulement `main` ou `main` et `dev` par exemple.   
Vous pouvez aussi bien s√ªr cr√©er votre propre convention, faites en sorte qu'elle soit la plus collective possible ! Et rappelez-vous que le principal c'est de rester branch√© üòé.
#### Bonnes pratiques sur les branches

De mani√®re g√©n√©rale :

- une personne par branche (cr√©er une autre branche √† partir d'une autre si besoin)
- une branche par sujet : ajout/modification d'une configuration,  ajout/modification d'une fonctionnalit√© 
- R√©soudre les merge conflicts dans une branche plut√¥t que dans la branche principale (ramener dans la branche les modifs de la branche principale avec `git merge`, expliqu√© plus bas). 
- Utiliser `git merge` et non `git rebase`

## Actions fr√©quentes

### Merge conflicts

Voyons quand et comment se cr√©e et se r√©sout un merge conflict (qui fait peur √† tant de d√©veloppeur).

=> Mettre une image d'une ombre terrifiante projet√©e depuis un lapin tout mignon.

Un merge conflict est un conflit de versions qui se d√©clare au moment d'un merge entre deux branches ou d'une Merge Request et lorsque les branches ont **diverg√©**.  

Les branches divergent √† deux conditions :

- Les deux branches ne partagent pas certains commits dans leur historique
- Dans ces commits non partag√©s, des modifications ont √©t√© apport√©es sur les m√™mes fichiers et m√™mes lignes

Un arbitrage va √™tre n√©cessaire pour d√©cider de la version √† garder. Une fois cet arbitrage effectu√© les historiques seront resynchronis√©s.

Exemple : 

Imaginons le fichier initial `hello.py` suivant dans un repo quelconque :

```python
def say_hello():
	print("Bonjour")
```

Miguel modifie sur la branche `main` tandis que Maria cr√©e sa branche `maria`. Tout deux commitent leurs modifications.

| Modifications de Miguel    | Modifications de Maria |
| -------------------------- | ---------------------- |
| `print("Buenos dias")`<br> | `print("Buongiorno")`  |

Avant le merge nous sommes donc dans cette situation.
```txt
		  C maria
		 /
	0---A---B main
```

Les conditions sont r√©unies pour cr√©er un merge conflict car les branches ont diverg√© :

- `B` et `C` sont des commits qui ne sont pas partag√©s par `maria` et `main` 
- `B` et `C` pr√©sentent chacun des modifications du m√™me fichier `hello.py` et des m√™mes lignes

Miguel r√©cup√®re la branche de Maria et tente de faire un merge :  
=> Cons√©quence : Merge Conflict !!!


![cone](../assets/images/cone-svgrepo-com.svg) **TP**  Cr√©er et r√©soudre un merge conflict

Cr√©er un nouveau repo et pr√©parer un merge conflict

```bash
mkdir hello_project
cd hello_project

# Cr√©ation commit initial
git init
echo -e 'def say_hello():\n    print("Bonjour")' > hello.py
git add hello.py && git commit -m "First commit"

# Modifications de Maria
git switch -c maria
echo -e 'def say_hello():\n    print("Buongiorno")' > hello.py
git add hello.py && git commit -m "Maria commit"

# Modifications de Miguel
git switch main
echo -e 'def say_hello():\n    print("Buenos dias")' > hello.py
git add hello.py && git commit -m "Miguel commit"

# Affichage du graphe des commits
git log --oneline --decorate --all --graph
```

Sortie :

<pre>* <font color="#A2734C">11741dd (</font><font color="#2AA1B3"><b>HEAD -&gt; </b></font><font color="#26A269"><b>main</b></font><font color="#A2734C">)</font> Miguel commit
<font color="#C01C28">|</font> * <font color="#A2734C">58808c5 (</font><font color="#26A269"><b>maria</b></font><font color="#A2734C">)</font> Maria commit
<font color="#C01C28">|/</font>  
* <font color="#A2734C">9c4b795</font> First commit</pre>


Notre projet est mature pour le merge. Allons-y :

```bash
# Fusion de maria dans main
git merge --no-ff maria # L'option --no-ff n'est pas n√©cessaire, ici ce n'est que cosm√©tique pour le graphe de commits
# Fusion automatique de hello.py
# CONFLIT (contenu) : Conflit de fusion dans hello.py
# La fusion automatique a √©chou√© ; r√©glez les conflits et validez le r√©sultat.
```

Mince un conflit appara√Æt regardons-√ßa de plus pr√®s : 
```bash
# Affichage du fichier hello.py
vim hello.py
```
Sortie :

```python
def say_hello():
<<<<<<< HEAD
    print("Buenos dias")
=======
    print("Buongiorno")
>>>>>>> maria
```

Git a √©crit directement dans le fichier et a indiqu√© les conflits de versions. Il va falloir arbitrer. Pour cela il faut ouvrir le fichier et supprimer √† la main les lignes que l'on ne souhaite pas garder ou faire les modifications qui nous conviennent. 

```bash
# Au choix :
# Ah mince la boulette ! Revenir au stade avant le merge
git merge --abort
# Ou faire un arbitrage et supprimer la section qui ne nous convient pas
nano hello.py 
vim hello.py 
gedit hello.py

# Faire un commit de merge 
git add hello.py && git commit -m "Merge conflict solved"
git log --oneline --decorate --all --graph
```

Sortie : 

<pre>*   <font color="#A2734C">6f128c4 (</font><font color="#2AA1B3"><b>HEAD -&gt; </b></font><font color="#26A269"><b>main</b></font><font color="#A2734C">)</font> Merge conflict solved
<font color="#C01C28">|</font><font color="#26A269">\</font>  
<font color="#C01C28">|</font> * <font color="#A2734C">58808c5 (</font><font color="#26A269"><b>maria</b></font><font color="#A2734C">)</font> Maria commit
* <font color="#26A269">|</font> <font color="#A2734C">11741dd</font> Miguel commit
<font color="#26A269">|/</font>  
* <font color="#A2734C">9c4b795</font> First commit
</pre>

Nous sommes carr√©s !

---

#### Bonnes pratiques

- On peut √©galement utiliser des outils graphiques pour la r√©solutions de conflits comme [meld](https://meldmerge.org/) ou des √©diteurs comme VSCode (ou VSCodium), Intellij, PyCharm ... 
- Je vous conseille √©galement fortement d'utiliser `git worktree` pour la gestion des branches et √©viter des merge conflicts tout √† fait inutile du √† des switch entre branches. En savoir plus sur cet article [Git worktree : se d√©nouer les branches](https://leolelonquer.github.io/blog/2023/04/08/git-worktree.html) 

**Par rapport aux branches**  
On r√©sout les merge conflict dans les branches feature plut√¥t que dans la branche main pour ne pas pourrir la branche main.  
L'id√©e est de rapatrier toutes les modifications qui ont eu lieu dans la branche principale et de r√©soudre les probl√®mes dans un endroit qui n'impacte pas la production.  
Donc de mani√®re g√©n√©rale, avant de merge une feature dans un main, faire le merge de main dans feature puis feature dans main.

Exemple : 

```bash
git switch main
git merge maria
# CONFLIT
git merge --abort
git switch maria
git merge main
# CONFLIT
vim hello.py 
git add hello.py && git commit -m "Merge conflict solved"
git switch main
git merge maria
```

### Explorer une version pr√©c√©dente

Si vous souhaitez juste explorer une version pr√©c√©dente sans cr√©er de commit
```bash
git log --oneline
git checkout SHA 

git checkout - # Revenir √† la version courante
# ou
git checkout -b revert/mybranch # Cr√©er une branche √† partir de la version pr√©c√©dente 
```

### Revenir √† une version pr√©c√©dente
_git revert_

Si git est un outil de versionnement, alors une de ses fonctionnalit√©s principales est de pouvoir r√©tablir des versions pr√©c√©dentes (rollback). 
Cependant toutes les mani√®res de visiter le pass√© ne sont pas bonnes √† prendre.

=> mettre une image de paradoxe temporel

![cone](../assets/images/cone-svgrepo-com.svg) **TP** Faire un rollback de son projet  

Cr√©er un repo, cr√©er plusieurs commits et revenir √† une version plus ancienne

```bash
mkdir time_project
cd time_project

# Cr√©ation commit initial
git init
echo -e 'bonjour' > poesie.txt
git add poesie.txt && git commit -m "First commit"

echo -e 'coucou' >> poesie.txt
git add poesie.txt && git commit -m "Second commit"

echo -e 'hello' >> poesie.txt
git add poesie.txt && git commit -m "Third commit"

cat poesie.txt

git log --oneline
# a9d4887 (HEAD -> main) Third commit
# 5c2c3f7 Second commit
# d9d039d First commit
```

Imaginons que nous souhaitons revenir au premier commit (`d9d039d`).  
Nous allons utiliser la m√©thode `git revert` qui permet d'inverser les modifications d'un commit. En lui donnant une s√©rie de commits dans le bon ordre, on peut ainsi inverser une s√©rie de commit et revenir √† un √©tat pr√©c√©dent.

```bash
git revert d9d039d.. # d9d039d.. d√©signe un intervalle entre d9d039d et HEAD (d9d039d non compris)
cat poesie.txt
# First commit

git log --oneline
# 4e35ad9 (HEAD -> main) Revert "Second commit"
# b78f8c1 Revert "Third commit"
# a9d4887 Third commit
# 5c2c3f7 Second commit
# d9d039d First commit
```

Il y a plein de mani√®res de faire, je vous ai fait un tableau. Vous pouvez les tester.

| `git revert`                                                                                                      | `git log --oneline`                                                                                                                                                        | Commentaire                                                                                                                                                                                                                                                                  |
| ----------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `d9d039d..HEAD`<br/>`d9d039d..`<br/>`HEAD~2..HEAD`<br/>`HEAD~2..`<br/>`a9d4887 5c2c3f7`<br/>`HEAD HEAD~1`         | <pre>4e35ad9 (HEAD -> main) Revert "Second commit"<br/>b78f8c1 Revert "Third commit"<br/>a9d4887 Third commit<br/>5c2c3f7 Second commit<br/>d9d039d First commit<pre/><br> | En entr√©e on peut donner<br/>  - un intervalle (..) absolu avec num√©ro de commit ou relatif par rapport √† HEAD<br/>  - un ensemble de commit √† inverser avec r√©f√©rence absolue ou relative.<br/>Dans les deux cas, pour chaque commit invers√©, on obtient un nouveau commit. |
| `--no-commit d9d039d..HEAD`<br/>`-no-commit d9d039d..`<br/>...<br/> + `git commit -m "All reverts in one commit"` | <pre>1f4f434 (HEAD -> main) All reverts in one commit<br/>a9d4887 Third commit<br/>5c2c3f7 Second commit<br/>d9d039d First commit<pre/><br>                                | Idem sauf qu'ici on a pas un commit pour chaque revert                                                                                                                                                                                                                       |

Bref voici la commande qui permet de cr√©er un commit de rollback que je recommande pour 90% des usages : 
```bash
git revert --no-edit --no-commit SHA.. # SHA : num√©ro de commit sp√©cifiant celui auquel vous souhaitez revenir 
git commit -m "Rollback to commit SHA"
```

## Gitlab

### Le repo distant
_git push, git pull_

Vous travaillez actuellement seulement avec un repo local. Pour partager votre travail, vous pouvez utiliser un repo distant.
Un repo distant est une copie du repo local (ou inversement). Voyons les comme des repos mirroirs. Les historiques sont conserv√©s des deux c√¥t√©s. Cependant ce sera plus g√©n√©ralement le repo distant qui sera la r√©f√©rence.

A chaque branche locale correspond une branche mirroir dans le repo distant. La synchronisation n'est cependant pas automatique.

| local   | distant        |
| ------- | -------------- |
| `main`  | `origin/main`  |
| `topic` | `origin/topic` |

Etant donn√© que la branche mirroir est une branche, on pourrait tout √† fait utiliser `git merge` pour faire la synchro.
Heureusement il existe des commandes sp√©cifiques pour cela : `git push` et `git pull`.

Gitlab et Github sont des solutions qui permettent d'h√©berger les repos distants.  
L'Ifremer h√©berge lui-m√™me une instance Gitlab.

![cone](../assets/images/cone-svgrepo-com.svg) **TP**   Cr√©er un projet sur Gitlab et y d√©poser des donn√©es

Cr√©ons un projet en ligne

1. se connecter √† <https://gitlab.ifremer.fr>
2. √† c√¥t√© de son ic√¥ne de profil, cliquer sur `+`  > New project/repository
3. Choisir Blank project 
4. Remplir les champs comme suit :
	- Project name : test-project  
	- Project URL : descendre tout en bas de la liste et choisir son user
	- Laisser les autres champs
5. Vous arrivez sur une page avec une vision g√©n√©rale de votre nouveau projet.
	- Notez que le contenu du fichier `README.md`, √©crit en markdown, est pr√©sent√© comme page d'accueil. C'est le fichier utilis√© par convention comme fichier d'accueil sur Gitlab et Github
 
R√©cup√©rons le projet localement :

1. Cliquer sur Code >  Clone with HTTPS
2. Ex√©cuter les commandes suivantes

```bash
git clone [url du projet]
git switch -c test
echo "bonjour" > toto.txt
git add toto.txt && git commit -m "bonjour"
git push

git pull
```

```txt
 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 ‚îÇWorking Tree‚îÇ‚îÇStaging Area‚îÇ‚îÇLocal Repo‚îÇ‚îÇRemote Repo‚îÇ
 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ             ‚îÇ            ‚îÇ            ‚îÇ      
       ‚îÇ   git add   ‚îÇ            ‚îÇ            ‚îÇ      
       ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ            ‚îÇ            ‚îÇ      
       ‚îÇ             ‚îÇ            ‚îÇ            ‚îÇ      
       ‚îÇ             ‚îÇ git commit ‚îÇ            ‚îÇ      
       ‚îÇ             ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ            ‚îÇ      
       ‚îÇ             ‚îÇ            ‚îÇ            ‚îÇ      
       ‚îÇ             ‚îÇ            ‚îÇ  git push  ‚îÇ      
       ‚îÇ             ‚îÇ            ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ      
       ‚îÇ             ‚îÇ            ‚îÇ            ‚îÇ      
       ‚îÇ             ‚îÇ            ‚îÇ  git pull  ‚îÇ      
       ‚îÇ             ‚îÇ            ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ      
       ‚îÇ             ‚îÇ            ‚îÇ            ‚îÇ      
       ‚îÇ       git checkout       ‚îÇ            ‚îÇ      
       ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ            ‚îÇ      
       ‚îÇ             ‚îÇ            ‚îÇ            ‚îÇ      
       ‚îÇ        git merge         ‚îÇ            ‚îÇ      
       ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ            ‚îÇ      
```
_Remote repo : 4√®me zone de r√©f√©rencement des fichiers_

`git push` et `git pull` permettent de synchroniser le repo local `.git` et le repo distant `test-project.git` 

3. Se rendre de nouveau sur le projet et sur la branche test. Voir les modifications


### Les Merge Requests

Gitlab est le lieu du travail en commun et de l'√©change. Toutes les actions techniques qui sont effectu√©es dans Gitlab peuvent tout √† fait l'√™tre localement. Gitlab rajoute des fonctionnalit√©s pour la discussion et l'annotation, les tickets de fonctionnalit√©, les rapports de bug, etc.

Gitlab est comme un Parlement :

- les repos qu'il h√©berge sont des codes de lois
- les d√©veloppeurs des parlementaires
- les merge request des propositions de lois soumises √† l'approbation pour int√©grer le texte de r√©f√©rence.
- les annotations des amendements
- un ticket est une demande d'unn acteur sur un sujet

Ici nous allons voir la Merge Request qui est une des fonctionnalit√©s les plus utilis√©es de Gitlab (Pull Request sur Github).

Les Merge requests sont des demandes de merge d'une branche dans une autre.

![cone](../assets/images/cone-svgrepo-com.svg) **TP**  Cr√©er un projet collaboratif et faire des merge requests

1. Une personne se rend sur le [projet la-fontaine](https://gitlab.ifremer.fr/ll7aa35/la-fontaine) et le fork dans son propre espace
2. Ajouter les droits aux autres membres de l'Assembl√©e
3. Tout le monde clone le projet
4. Chacun cr√©e sa branche 
5. Chacun ouvre le fichier `corbeau-vs-renard.md`  et chacun change une ligne (une personne la premi√®re ligne, une autre celle du milieu, et une troisi√®me la derni√®re)
6. Chacun pousse ses modifs
7. Chacun se rend sur le projet et cr√©e une merge request depuis sa branche vers la branche `main` en mettant en reviewers les coll√®gues
8. Apr√®s v√©rifications, chacun valide les merge request des autres
9. Chacun fait le merge de la merge request de quelqu'un d'autre
10. En local, chacun revient sur son repo, revient sur la branche `main` et r√©cup√®re la modif du repo distant.
11. Chacun v√©rifie que le fichier a bien √©t√© modifi√©.

Bonus:   
Vous pouvez ramener les modifs de la branche `main` dans votre branche pour continuer le d√©veloppement dans votre branche sans avoir √† en cr√©er une autre.

1. revenir sur sa branche
2. `git merge main`

## Bon √† savoir

### Le fichier `.gitignore`

Le fichier `.gitignore` permet d'√©viter l'indexation de certains documents sur le crit√®re de patterns. Il se trouve √† la racine de l'arbre de travail. On peut ignorer :

- des fichiers sp√©cifiques
- des patterns de fichiers
- des dossiers

ex de fichier `.gitignore`:

```python
# Ignorer les fichiers de configuration de l'environnement de d√©veloppement
.idea/
.vscode/
.classpath
.project

# Ignorer les fichiers de sauvegarde temporaires
*~
*.swp

# Ignorer les fichiers de logs
*.log

# Ignorer certains dossiers
lib/
var/
tmp/
tdsConfigGen/
```

Une fois que notre fichier est bien configur√©, on peut indexer et commiter plus rapidement sans se soucier de l'indexation de fichiers inutiles :

```bash
git add . && git commit -m "Mon message"
```

### Quelques outils et conseils en vrac

- `git lfs` : git n'a pas √©t√© con√ßu pour stocker des fichiers de volume important. Git LFS permet de stocker dans un espace sp√©cifique pour ces fichiers. Pratique pour des donn√©es de r√©f√©rence, de tests etc. A utiliser avec pr√©caution, l'administration est difficile et la configuration opaque. Quelques documentations de RIC sur `git-lfs` : [fichiers volumineux](https://gitlab.ifremer.fr/ricweb/gitlab/-/wikis/fichiers-volumineux) et [repo exemple git lfs](https://gitlab.ifremer.fr/ricweb/gitlab-lfs)
- `git worktree` : si j'avais su que git worktree existait plus t√¥t, j'aurais pu construire la tour Eiffel 3 fois au lieu de perdre mon temps dans des merges conflicts r√©sultant d'un switch entre branches. Git worktree permet de rattacher une branche √† un arbre de travail sp√©cifiquement, c'est √† dire un dossier par branche. Pour plus d'info : [Git worktree : se d√©nouer les branches](https://leolelonquer.github.io/blog/dev/git-worktree)
- `git stash` : commande permettant de mettre de c√¥t√© des modifs, de faire des op√©rations de branches, puis de r√©appliquer les modifs.
- `man git-cmd` : pour obtenir le r√©f√©rentiel complet des options d'une commande git. `git cmd --help` ouvre aussi les manpages 
- `tldr git-cmd` : pour obtenir les options et les utilisations les plus fr√©quentes d'une commande git. `tdlr` reste √† installer mais il y a un [site internet](https://tldr.inbrowser.app/)
- Pourquoi utiliser `git revert` et pas `git reset` ?"   
`git reset` est une commande qui permet d'√©craser l'historique. Or, s'il y a bien une chose que git n'aime pas pour le travail collaboratif, c'est modifier l'historique. Des historiques non synchronis√©s = probl√®mes assur√©s. N'utilisez `git reset` que si vous √™tes seul sur votre projet ou seul sur votre branche. Et encore pour ce dernier cas, j'√©viterai sauf √† plein de conditions.  
Dans l'id√©e, il faut toujours aller de l'avant, un rollback est aussi une modification comme une autre qui m√©rite d'√™tre conserv√©e dans l'historique.

| `git reset`                          | `git log --oneline`                            | Commentaire                                                                                                                                                            |
| ------------------------------------ | ---------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `--hard d9d039d`<br/>`--hard HEAD~2` | <pre>d9d039d (HEAD -> main) First commit<pre/> | Tout l'historique et les modifications jusqu'√† d9d039d seront effac√©s                                                                                                  |
| `--soft d9d039d`<br/>`--soft HEAD~2` | <pre>d9d039d (HEAD -> main) First commit<pre/> | Seulement l'historique jusqu'√† d9d039d est effac√©,<br/>les modifications sont conserv√©es mais √† recommiter.<br/>Faire un `git status` pour voir les fichiers √† valider |


Versionnement de donn√©es ?

TODO :
- git diff

## Ressources

- Pr√©sentation anim√©e des principales commandes git : [CS Visualized: Useful Git Commands ](https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1)
- Liste des commandes Git : [git reference](https://git-scm.com/docs)
- Ensemble de tutos Git : [Atlassian git tutorial](https://www.atlassian.com/git)
- Codes de triche Git : [Gitlab Cheatsheet](https://about.gitlab.com/images/press/git-cheat-sheet.pdf)
- Cours de Pierre Giraud : [Apprendre √† utiliser Git et GitHub - Cours Complet (2020)](https://www.pierre-giraud.com/git-github-apprendre-cours/)
- S√©rie de vid√©os tr√®s accessibles de l'Inria (10mins chaque) - D√©mystifions Git, Github, Gitlab :
	1. [Notion d‚Äôhistorique](https://www.youtube.com/watch?v=iub0_uVWGmg)
	2. [Travailler √† plusieurs](https://www.youtube.com/watch?v=4xsd8jHyVpk)
	3. [L‚Äô√©cosyst√®me Git](https://www.youtube.com/watch?v=5EFyKBF1wWw)
