---
layout: article
category: dev
tags:
  - full_post
title: Git - 1 - Concepts de base
---
_git init, git status, git add, git commit, git log, git checkout, git tag_

Dans cette partie, nous allons voir les concepts et les commandes de base : les d√©p√¥ts, les commits, les branches.

<!--more-->

# D√©p√¥t
_git init, git status_ 

Imaginons le projet avec l'arborescence suivante : 

<pre><font color="#97bff0"><b>myproject/</b></font>
‚îî‚îÄ‚îÄ toto.txt
</pre>

Pour sauvegarder le contenu de dir, nous allons cr√©er un d√©p√¥t (repository ou repo) git.  
Nous obtenons l'arborescence suivante :

<pre><font color="#97bff0"><b>myproject/</b></font> => Arbre de travail
‚îú‚îÄ‚îÄ toto.txt
‚îî‚îÄ‚îÄ <font color="#97bff0"><b>.git</b></font> => D√©p√¥t
</pre>

Toutes les informations de versionnement seront stock√©es le dossier `.git`. Ce dossier est appel√© d√©p√¥t. Il pourrait √™tre stock√© n'importe o√π.  
Le dossier `myproject` est l'arbre de travail. C'est dans ce dossier qu'on peut apporter des modifications √† nos fichiers et les versionner. 

Le fichier `toto.txt` n'aura pas besoin de changer de nom.

![cone](https://leolelonquer.github.io/blog/assets/images/cone-svgrepo-com.svg) **TP**  Cr√©er et initialiser son projet

Ouvrir un terminal 
```bash
mkdir myproject # Cr√©er le dossier
cd myproject # Aller dans le dossier
echo "bonjour" > toto.txt # Cr√©er un fichier toto.txt
git init # initialiser le projet en tant 
ls -a # V√©rfier l'existence du dossier .git
# .  ..  .git  toto.txt

git status # Afficher le statut de l'arbre de travail
```
Sortie :

<pre>Sur la branche main

Aucun commit

Fichiers non suivis:
  (utilisez &quot;git add &lt;fichier&gt;...&quot; pour inclure dans ce qui sera valid√©)
	<font color="#fa2d3c">toto.txt</font>

aucune modification ajout√©e √† la validation mais des fichiers non suivis sont pr√©sents (utilisez &quot;git add&quot; pour les suivre)
</pre>

Pas g√©nial, ya du rouge. La suite dans le TP suivant.

# Commit (r√©vision/version)
_git add, git commit, git log_ 

Le repo est initialis√©, mais rien n'a encore √©t√© versionn√© dans le repo.   
Dans git, une version/r√©vision est appel√©e un commit.

Pour cr√©er un commit, il y a deux √©tapes :  

1. `git add` a deux fonctions : 
    - ajouter des nouveaux fichiers √† l'index des fichiers suivis par git
    - stocker les modifications dans une zone interm√©diaire, la staging area (zone de transit) qui nous permet de faire de la v√©rification sur les fichiers qu'on int√®gre dans une r√©vision. 
2. `git commit` : sauvegarde les modifications de tous les fichiers pr√©sents dans la staging area dans le dossier `.git/` et produit un commit avec une cl√© SHA1.

```txt
 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
 ‚îÇWorking Tree‚îÇ‚îÇStaging Area‚îÇ‚îÇLocal Repo‚îÇ
 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ             ‚îÇ            ‚îÇ      
       ‚îÇ   git add   ‚îÇ            ‚îÇ      
       ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ            ‚îÇ      
       ‚îÇ             ‚îÇ            ‚îÇ      
       ‚îÇ             ‚îÇ git commit ‚îÇ      
       ‚îÇ             ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ>‚îÇ      
       ‚îÇ             ‚îÇ            ‚îÇ      
       ‚îÇ   git checkout/switch    ‚îÇ      
       ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ      
       ‚îÇ             ‚îÇ            ‚îÇ      
       ‚îÇ        git merge         ‚îÇ      
       ‚îÇ<‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÇ      
```

_Un fichier peut √™tre r√©f√©renc√© dans 3 zones : l'arbre de travail, la zone de transit et le d√©p√¥t._  
_Pour le versionnement, il devra passer par ces trois zones successivement._

A chaque fois que vous versionner gr√¢ce aux commandes `git add` + `git commit`, vous cr√©ez un nouveau commit qui s'ajoute dans une cha√Æne, une lign√©e de commits. 

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇcommit C‚îÇ C h√©rite de B
‚îî‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚ñΩ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇcommit B‚îÇ B h√©rite de A
‚îî‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚ñΩ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇcommit A‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```
_Exemple de graphe de lign√©e de commits. Le commit le plus r√©cent est C, B est son commit parent. A est le commit le plus ancien._

Plus pr√©cis√©ment, pour chaque commit, il se passe ceci :

- Git versionne sur l'int√©gralit√© de l'arbre de travail. Lors de la cr√©ation d'un commit, git fait une photographie de l'instant en stockant les modifications apport√©es dans le projet dans le dossier `.git/` et en attribuant √† cette photographie un identifiant cryptographique unique SHA1 (ex: `338b0b72fefb35d6e374127768aed10642aada0b`, raccourci en 7 caract√®res `338b0b7`)  
- Chaque commit est associ√© √† un ou plusieurs commits parents ce qui nous permettra de retrouver l'historique.

!!! tip
	C'est √† vous de choisir √† quel moment versionner votre travail. Il n'y a pas vraiment de convention. Consid√©rez simplement un moment qui est un point de sauvegarde pour votre projet. Vous pouvez versionner autant que vous voulez, git est tr√®s robuste quant au nombre de commits.

![cone](https://leolelonquer.github.io/blog/assets/images/cone-svgrepo-com.svg) **TP**  Versionner son projet
```bash
git add toto.txt # Ajout √† l'index et stockage des modifications dans la staging area 
git commit -m "Mon premier commit" # Cr√©ation d'un commit avec un message
git log # Visualisation de l'historique de commits
```
Sortie :

<pre><font color="#A2734C">commit 34c9d3c50746bf01df0e3e7a9ec9c59f2803aa17 (</font><font color="#2AA1B3"><b>HEAD -&gt; </b></font><font color="#26A269"><b>main</b></font><font color="#A2734C">)</font>
Author: L√©o Le Lonquer &lt;leo.le.lonquer@bidulon.fr&gt;
Date:   Thu Apr 4 09:50:48 2024 +0200

    Mon premier commit
</pre>

Amusez-vous √† modifier le fichier `toto.txt`, √† le versionner, √† v√©rifier l'√©tat de votre repo avec `git status` et √† regarder les logs avec `git log`.

# Branches et arborescence üåø

## Branchage et merge
_git branch, git switch, git merge_

Pour l'instant nous √©tions sur un repo tr√®s simple. Imaginons que nous voulons ajouter une fonctionnalit√© sans casser l'√©tat actuel de notre projet. Nous pouvons cr√©er une branche qui permettra de travailler √† c√¥t√© sur cette nouvelle fonctionnalit√© tranquillement.  

- Nous pouvons cr√©er autant de branches que souhait√©, √† partir de n'importe quelle branche. Vous allez donc cr√©er une arborescence, qui s'apparente √† un arbre g√©n√©alogique.
- Par d√©faut, nous sommes la branche principale `main` (`master` pour des projets plus anciens).

```txt
		  E---F---G topic
		 /
	A---B---C---D main
```
_Graphe d'un repo pr√©sentant une branche `topic` issue de la branche `main`_


Une fois que les fonctionnalit√©s sont d√©velopp√©es et matures, nous pouvons ramener les modifications d'une branche dans une autre. C'est ce qu'on appelle un merge.

```txt
		  E---F---G topic
		 /         \
	A---B---C---D---H main
```
_Exemple de graphe apr√®s un merge_

![cone](https://leolelonquer.github.io/blog/assets/images/cone-svgrepo-com.svg) **TP 1**  Cr√©er une branche, basculer dessus et observer les effets du basculement

Toujours avec le m√™me projet

```bash
git branch topic # Cr√©er la branche √† partir du dernier commit
git switch topic # changer de branche
# Ou les deux commandes en une
git switch -c topic

git branch # Afficher les branches existantes
#   main
# * topic
```

Vous ne verrez pas de diff√©rences au premier abord. Ajoutons un fichier et versionnons l'√©tat.

```bash
echo "coucou" > tutu.py # Cr√©er un nouveau fichier
git add . && git commit -m "Premier commit de la branche topic"
ls 
# toto.txt  tutu.py
```

Une fois commit√© revenons √† main.

```bash
git switch main
ls # O√π est pass√© le fichier `tutu.py` ?
# toto.txt

git log
```

Vous ne verrez pas le commit avec le message "Premier commit de la branche topic" car vous √™tes sur la branche `main` qui n'a pas encore int√©gr√© les modifications faites sur `topic` (heureusement !). 

Rassurez-vous le fichier `tutu.py` n'est pas perdu, il est simplement dans le dossier `.git/` et attend que vous reveniez le voir. Git s'est charg√© de modifier votre espace de travail courant pour revenir √† un espace de travail correspondant √† une autre branche.

```bash
git switch topic # Revenons √† la branche topic
ls # Le fichier tutu.py r√©appara√Æt
# toto.txt  tutu.py
```

![cone](https://leolelonquer.github.io/blog/assets/images/cone-svgrepo-com.svg)**TP 2** Faire un merge

Maintenant imaginons que nous avons termin√© le d√©veloppement de notre fonctionnalit√©, nous voulons r√©int√©grer les d√©veloppement dans la branche principale.

Le graphe de commit ests dans l'√©tat suivant : 
```txt
		  B topic
		 /
	0---A main
```

Ex√©cutons le merge
```bash
git switch main 
git merge topic --no-ff # l'option --no-ff est pour la cosm√©tique du graphe de commits, elle n'est pas utilis√©e usuellement
ls # tutu.py est pr√©sent
```

git cr√©e un nouveau commit appel√© merge commit pour signaler que vous avez int√©gr√© les modifications du dernier commit de la branche topic.

Le graphe de commits se retrouve dans l'√©tat suivant :
```txt
		  B topic
		 / \
	0---A---C main
```
## Les r√©f√©rences (branche-HEAD-tag)
_git log --graph, git checkout, git tag_

Les r√©f√©rences sont des pointeurs qui identifient un commit dans un graphe de commits. Il existe trois types de r√©f√©rences :

- **HEAD** : c'est la r√©f√©rence de l'arbre de travail courant. A chaque commit, il est mis √† jour. Il peut avoir deux √©tats :
	- **attach√©** : il pointe vers une branche qui elle-m√™me pointe vers un commit
	- **d√©tach√©** : il ne pointe vers aucune branche, mais vers n'importe quel commit du graphe
- **les branches** : les branches ne sont en r√©alit√© que des pointeurs. Elles identifient un dernier commit d'une cha√Æne de commits. L'h√©ritage se fait de proche en proche (rappelez-vous les commits stockent leur commit parent.). Si HEAD est associ√© √† la branche, alors la r√©f√©rence de la branche est mise √† jour lors d'un commit.
- **tag** : r√©f√©rence immutable (qui n'est jamais mis √† jour) permettant de labeliser des commits plus importants que d'autres (ex : une version livrable du projet).

```
                 ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                 ‚îÇcommit W (topic <= HEAD)‚îÇ
                 ‚îî‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñΩ‚îê                                 
‚îÇcommit X (main)   ‚îÇ                                 
‚îî‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                 
‚îå‚ñΩ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                           
‚îÇcommit Y‚îÇ                                           
‚îî‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                           
‚îå‚ñΩ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                           
‚îÇcommit Z‚îÇ                                           
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                           
```
_Exemple de graphe et des pointeurs_

![cone](https://leolelonquer.github.io/blog/assets/images/cone-svgrepo-com.svg) **TP**  Se balader dans le graphe des commits

Vous pouvez afficher le graphe de commits ainsi que l'√©tat des pointeurs 
```bash 
git log --oneline --decorate --all --graph
```
Sortie :

<pre>*   <font color="#A2734C">316d42d (</font><font color="#2AA1B3"><b>HEAD -&gt; </b></font><font color="#26A269"><b>main</b></font><font color="#A2734C">)</font> Merge branch &apos;topic&apos;
<font color="#fa2d3c">|</font><font color="#26A269">\</font>  
<font color="#fa2d3c">|</font> * <font color="#A2734C">f6c8d25 (</font><font color="#26A269"><b>topic</b></font><font color="#A2734C">)</font> Premier commit de la branche topic
<font color="#fa2d3c">|/</font>  
* <font color="#A2734C">65b6302</font> Mon premier commit
</pre>

Nous observons le graphe r√©sultant du merge pr√©c√©dent.   
D√©pla√ßons nous dans un commit :
```bash
git checkout 65b6302
ls
# toto.txt
```

R√©examinons la carte :
```bash
# Revoir la carte et regarder o√π est plac√© le point HEAD
git log --oneline --decorate --all --graph 
```
Sortie :

<pre>*   <font color="#A2734C">316d42d (</font><font color="#26A269"><b>main</b></font><font color="#A2734C">)</font> Merge branch &apos;topic&apos;
<font color="#fa2d3c">|</font><font color="#26A269">\</font>  
<font color="#fa2d3c">|</font> * <font color="#A2734C">f6c8d25 (</font><font color="#26A269"><b>topic</b></font><font color="#A2734C">)</font> Premier commit de la branche topic
<font color="#fa2d3c">|/</font>  
* <font color="#A2734C">65b6302 (</font><font color="#2AA1B3"><b>HEAD</b></font><font color="#A2734C">)</font> Mon premier commit
</pre>

Nous observons que le pointeur `HEAD` s'est d√©plac√© sur le commit `65b6302`. Nous retrouvons uniquement les fichiers qui correspondent √† ce commit.

Repla√ßons HEAD √† son pointage pr√©c√©dent
```bash
git checkout - 
git log --oneline --decorate --all --graph 
```
Nous retrouvons le premier graphe.

## Convention de nommage de branche

Les branches peuvent √™tre utilis√©es et nomm√©es tr√®s librement. Cependant quelques conventions ont √©t√© cr√©√©es pour que les d√©veloppeurs retrouvent leurs marques entre diff√©rents projets. Je vous pr√©sente ici la nomenclature [git-flow](https://danielkummer.github.io/git-flow-cheatsheet/index.fr_FR.html) : 

1. la branche `main` ou `master` : c'est la branche principale, de r√©f√©rence, qui reproduit la production. Elle doit toujours √™tre fonctionnelle.
2. la branche `dev` ou `develop` : c'est la branche de d√©veloppement, celle qui va proposer une nouvelle version d'un logiciel et dans laquelle on va merger toutes les features.
3. `feature` : ce sont les branches d'ajout de fonctionnalit√©s. Elles sont nomm√©es g√©n√©ralement `feature/[ma_fonctionnalite]` (ex : `feature/add_refresh_button`). Dans certaines organisations, on r√©f√©rence le num√©ro de ticket correspondant √† la feature (ex: `feature/DTL-92_add_refresh_button` voire m√™me simplement `feature/DTL-92`)
4. `hotfix` : pour corriger un bug dans la branche de production `main` et la reporter dans `dev` 

Pour des d√©veloppements simples, si vous √™tes le seul contributeur, vous pouvez utiliser seulement `main` ou `main` et `dev` par exemple.   
Vous pouvez aussi bien s√ªr cr√©er votre propre convention, faites en sorte qu'elle soit la plus collective possible ! Et rappelez-vous que le principal c'est de rester branch√© üòé.
## Bonnes pratiques sur les branches

De mani√®re g√©n√©rale :

- une personne par branche (cr√©er une autre branche √† partir d'une autre si besoin)
- une branche par sujet : ajout/modification d'une configuration,  ajout/modification d'une fonctionnalit√© 
- R√©soudre les merge conflicts dans une branche plut√¥t que dans la branche principale (ramener dans la branche les modifs de la branche principale avec `git merge`, expliqu√© plus bas). 
- Utiliser `git merge` et non `git rebase`

# La suite

La suite ici : [Git - 2 - Actions fr√©quentes](git-2)

# Ressources

- Pr√©sentation anim√©e des principales commandes git : [CS Visualized: Useful Git Commands ](https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1)
- Codes de triche Git : [Gitlab Cheatsheet](https://about.gitlab.com/images/press/git-cheat-sheet.pdf)